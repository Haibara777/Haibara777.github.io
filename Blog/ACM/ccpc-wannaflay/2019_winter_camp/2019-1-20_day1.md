# CCPC-Wannafly Winter Camp Day1

 今天，我知道了什么是绝望
>请组织放心，我一定会补题的

## A 机器人

分类讨论，据wls说有6种情况，嘤嘤嘤，等我肝好了再慢慢写吧。

## B 吃豆豆

	我们几个菜鸡今天差点爆零，在这里容我再吹一波于昊大佬，抱着
	大佬的大腿，我们了a这唯一一道题。

这道题乍一看不是dp就是搜索，但是走过的路还可以走，所以搜索是行不通了，只能dp，于昊大佬的思路是 i , j , t dp三维，t就是当前时间，dp[i][j][t]就是第t秒( i , j )处最多获得的糖果数，需要注意的就是需要一个v数组来记录第t秒( i , j )是否到达过。

这道题div1版本的糖果数是1e18，因此要每2520秒循环一次，提前dp出一次循环中可拿到的最大糖果数k，然后将糖果数模k，再dp剩下的，但是因为我水平过低，不知道该如何dp，因此div1版本我真的做不出来。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=10005;
int a[20][20];
int dp[20][20][12005];
int dx[5]={0,0,1,0,-1};
int dy[5]={0,1,0,-1,0};
int v[20][20][12005]={0};
int main()
{
	ios::sync_with_stdio(false);
	int n,m,C;
	cin>>n>>m>>C;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	int sx,sy,ex,ey;
	cin>>sx>>sy>>ex>>ey;
	v[sx][sy][0]=1;
	for(int t=1;t<=C*20;t++)
	{
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				for(int k=0;k<=4;k++)
				{
					int x1=i+dx[k],y1=j+dy[k];
					if(v[x1][y1][t-1]==0)continue;
					v[i][j][t]=1;
					dp[i][j][t]=max(dp[i][j][t],dp[x1][y1][t-1]);
				}
				if(t%a[i][j]==0&&v[i][j][t])dp[i][j][t]++;
				if(dp[ex][ey][t]>=C){
					cout<<t<<endl;
					return 0;
				}
			}
	}
}
```

## C 拆拆拆数

c题还是挣扎了很久的，但是并没有什么卵用，显而易见的是只要是题目给的数据，就一定有解，且n<=2，当a，b互质时n=1，否则n=2，但是难以证明，且拆数还是很困难的，参照别人的方法，可以拆出2 2，2 3，3 4中的一种，但是本菜鸡目前还是不会证明。

## D 超难的数学题

	unsolved

## E 流流流动

	unsolved

## F 爬爬爬山

	unsolved

## G 双重矩阵

	unsolved

## H 我爱割葱

	unsolved

## I 起起落落

	unsolved
	
## J 夺宝奇兵

	unsolved

## K 星球大战

	unsolved

